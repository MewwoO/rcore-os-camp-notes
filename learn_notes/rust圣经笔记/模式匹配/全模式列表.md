# 全模式列表

## 匹配字面值
```rust
let x = 1;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
}

// 运行结果
// one
```

## 匹配命名变量
```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        // 变量遮蔽，这是的y是在match作用域内的一个新变量
        // 而不是main作用域内的y
        Some(y) => println!("Matched, y = {:?}", y), 
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {:?}", x, y);
}

// 运行结果
// Matched, y = 5
// at the end: x = Some(5), y = 10
```

## 单分支多模式
- 在 match 表达式中，可以使用 `|` 语法匹配多个模式，它代表或的意思
```rust
let x = 1;

match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}

// 运行结果
// one or two
```

## 通过序列`..=`匹配值的范围
- `..=` 语法允许你匹配一个闭区间序列内的值
- 序列只允许用于数字或字符类型，原因是：
    - 它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型
```rust
let x = 5;

match x {
    1..=5 => println!("one through five"),
    _ => println!("something else"),
}

// 运行结果
// one through five

let x = 'c';

match x {
    'a'..='j' => println!("early ASCII letter"),
    'k'..='z' => println!("late ASCII letter"),
    _ => println!("something else"),
}

// 运行结果
// early ASCII letter
```

## 解构并分解值
- 使用模式解构结构体、枚举、元组、数组和引用

### 解构结构体
```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };
    // 创建了变量 a 和 b 
    // 来匹配结构体 p 中的 x 和 y 字段
    // 模式中的变量名不必与结构体中的字段名一致
    // 不过通常希望变量名与字段名一致
    // 以便于理解变量来自于哪些字段
    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}

struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    // let Point { x: x, y: y } = p;
    // x 和 y 重复, 可以简写：
    // 只需列出结构体字段的名称，则模式创建的变量会有相同的名称
    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}

// 固定某个字段的匹配方式
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        // 只匹配 y 为 0 的情况
        Point { x, y: 0 } => println!("On the x axis at {}", x),
        // 只匹配 x 为 0 的情况
        Point { x: 0, y } => println!("On the y axis at {}", y),
        // 匹配 x 和 y 都不为 0 的情况
        Point { x, y } => println!("On neither axis: ({}, {})", x, y),
    }
}
```

### 解构枚举
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        // Message::Quit 这样没有任何数据的枚举成员，
        // 不能进一步解构其值。只能匹配其字面值 Message::Quit，
        // 因此模式中没有任何变量
        Message::Quit => {
            println!("The Quit variant has no data to destructure.")
        }
        // 模式匹配一样要类型相同
        // 因此匹配 Message::Move{1,2} 这样的枚举值
        // 就必须要用 Message::Move{x,y} 这样的同类型模式才行
        Message::Move { x, y } => {
            println!(
                "Move in the x direction {} and in the y direction {}",
                x,
                y
            );
        }
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => {
            println!(
                "Change the color to red {}, green {}, and blue {}",
                r,
                g,
                b
            )
        }
    }
}
```

### 解构嵌套的结构体和枚举
```rust
enum Color {
   Rgb(i32, i32, i32),
   Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!(
                "Change the color to red {}, green {}, and blue {}",
                r,
                g,
                b
            )
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!(
                "Change the color to hue {}, saturation {}, and value {}",
                h,
                s,
                v
            )
        }
        _ => ()
    }
}
```

### 解构结构体和元组
```rust
struct Point {
     x: i32,
     y: i32,
 }

let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
```

### 解构数组
- 对于数组，我们可以用类似元组的方式解构，分为两种情况：
    - 定长数组
    - 不定长数组
```rust
// 定长数组
let arr: [u16; 2] = [114, 514];
let [x, y] = arr;

assert_eq!(x, 114);
assert_eq!(y, 514);


// 不定长数组
let arr: &[u16] = &[114, 514];
// 数组的第一个元素被绑定到变量x上
// ..表示剩余的元素（如果有的话）被忽略
if let [x, ..] = arr {
    // x是从切片中解构出来的
    // 所以它是一个对数组元素的引用，即 &u16类型
    assert_eq!(x, &114);
}
// 数组的所有前面的元素（如果有的话）被忽略
// 而最后一个元素被绑定到变量y上
if let &[.., y] = arr {
    // 为y是从切片中解构出来的最后一个元素，所以它的值是514，
    // 而不是引用。在Rust中，当解构数组或切片以获取其元素时，
    // 如果元素类型是基本类型（如整数、浮点数等），则直接获取其值，而不是引用
    // copy 特征，直接拷贝，存储在栈上，开销小
    assert_eq!(y, 514);
}

let arr: &[u16] = &[];
// 匹配任意长度的数组（包括空数组）
// ..表示“零个或多个元素”
assert!(matches!(arr, [..]));
// arr不能匹配模式[x, ..]
// [x, ..]意味着至少需要一个元素（绑定到x）
// 但arr是空的，所以不匹配
assert!(!matches!(arr, [x, ..]));
```

## 忽略模式中的值
- 使用 _ 忽略整个值
    - _ 模式作为 match 表达式最后的分支匹配所有剩余的值
    - _ 模式用于函数参数
        - 在一些情况下忽略函数参数会变得特别有用，比如实现特征时，当需要特定类型签名但是函数实现并不需要某个参数时。此时编译器就不会警告说存在未使用的函数参数，就跟使用命名参数一样
```rust
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {}", y);
}

fn main() {
    foo(3, 4);
}
```
- 使用嵌套的 _ 忽略部分值
    - 可以在一个模式内部使用 _ 忽略部分值
    - 可以在一个模式中的多处使用下划线来忽略特定值
```rust
// 在一个模式内部使用 _ 忽略部分值
let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    // 第一个匹配分支，我们不关心里面的值
    // 只关心元组中两个元素的类型，因此对于 Some 中的值，直接进行忽略
    (Some(_), Some(_)) => {
        println!("Can't overwrite an existing customized value");
    }
    _ => {
        setting_value = new_setting_value;
    }
}

println!("setting is {:?}", setting_value);

// 一个模式中的多处使用下划线来忽略特定值
let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) => {
        println!("Some numbers: {}, {}, {}", first, third, fifth)
    },
}
```

- 使用下划线开头忽略未使用的变量
- 注意：只使用 _ 和使用以下划线开头的名称有些微妙的不同：比如 _x 仍会将值绑定到变量，而 _ 则完全不会绑定
```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```

- 用 .. 忽略剩余值
    - .. 模式会忽略模式中剩余的任何没有显式匹配的值部分
```rust
// 结构体
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } => println!("x is {}", x),
}

// 元组
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        // first 和 last 来匹配第一个和最后一个值
        // .. 将匹配并忽略中间的所有值
        (first, .., last) => {
            println!("Some numbers: {}, {}", first, last);
        },
    }
}

// 使用 .. 必须是无歧义的
// 如果期望匹配和忽略的值是不明确的，Rust 会报错
// 如下:
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) => {
            println!("Some numbers: {}", second)
        },
    }
}
```

## 匹配守卫提供的额外条件
- 匹配守卫（match guard）是一个位于 match 分支模式之后的额外 if 条件，它能为分支模式提供更进一步的匹配条件
```rust
let num = Some(4);

match num {
    Some(x) if x < 5 => println!("less than five: {}", x),
    Some(x) => println!("{}", x),
    None => (),
}

// 使用匹配守卫来解决模式中变量覆盖的问题
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        // 匹配守卫 if n == y 并不是一个模式所以没有引入新变量
        // 这个 y 正是 外部的 y 而不是新的覆盖变量 y
        // 这样就可以通过比较 n 和 y 来表达寻找一个与外部 y 相同的值的概念了
        Some(n) if n == y => println!("Matched, n = {}", n),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {}", x, y);
}
```
- 在匹配守卫中使用 或 运算符 `|` 来指定多个模式，同时匹配守卫的条件会作用于所有的模式
```rust
let x = 4;
let y = false;

match x {
    // 匹配守卫 if y 作用于 4、5 和 6 
    // 在满足 x 属于 4 | 5 | 6 后
    // 判断 y 是否为 true
    4 | 5 | 6 if y => println!("yes"),
    _ => println!("no"),
}
```

## @绑定
- @（读作 at）运算符允许为一个字段绑定另外一个变量
    - 当你既想要限定分支范围，又想要使用分支的变量时，就可以用 @ 来绑定到一个新的变量
```rust
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    // 希望测试 Message::Hello 的 id 字段是否位于 3..=7 范围内
    // 同时也希望能将其值绑定到 id_variable 变量中
    // 以便此分支中相关的代码可以使用它
    // id_variable 也可以命名为 id, 与字段同名, 这里不同是为了方便理解
    Message::Hello { id: id_variable @ 3..=7 } => {
        println!("Found an id in range: {}", id_variable)
    },
    Message::Hello { id: 10..=12 } => {
        println!("Found an id in another range")
    },
    // 指定了一个没有范围的变量
    // 此时确实拥有可以用于分支代码的变量 id
    // 因为这里使用了结构体字段简写语法
    // 不过此分支中没有像头两个分支那样对 id 字段的值进行测试
    // 任何值都会匹配此分支
    Message::Hello { id } => {
        println!("Found some other id: {}", id)
    },
}
```

## @前绑定后解构(Rust 1.56 新增)
- 使用 @ 还可以在绑定新变量的同时，对目标进行解构：
```rust
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    // 绑定新变量 `p`，同时对 `Point` 进行解构
    let p @ Point {x: px, y: py } = Point {x: 10, y: 23};
    println!("x: {}, y: {}", px, py);
    println!("{:?}", p);


    let point = Point {x: 10, y: 5};
    if let p @ Point {x: 10, y} = point {
        println!("x is 10 and y is {} in {:?}", y, p);
    } else {
        println!("x was not 10 :(");
    }
}
```

## @新特性(Rust 1.53 新增)
```rust
fn main() {
    match 1 {
        // num @ 1 | 2 => { 编译不通过
        // 因为 num 没有绑定到所有的模式上，只绑定了模式 1
        // 使用下面这种方式在 Rust 1.53 之前的版本会报错，因为编译器不支持
        // 1.53 之后就可以
        num @ (1 | 2) => {
            println!("{}", num);
        }
        _ => {}
    }
}
```