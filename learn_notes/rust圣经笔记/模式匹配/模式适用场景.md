# 模式适用场景

## 模式（Pattern）
-  模式常和match 表达式联用，以实现强大的模式匹配能力。模式一般由以下内容组合而成：
    - 字面值
    - 解构的数组、枚举、结构体或者元组
    - 变量
    - 通配符
    - 占位符
- 所有可能用到模式的地方：
    - match 分支
        - match 匹配是穷尽式的，因此我们往往需要一个特殊的模式 _，来匹配剩余的所有情况
    - if let 分支
        - if let 允许匹配一种模式，而忽略其余的模式( 可驳模式匹配 )
    - while let 条件循环
        - 允许只要模式匹配就一直进行 while 循环
    - for 循环
        - 允许通过模式来解构出数组、元组、枚举、结构体中的值
    - let 语句
    - 函数参数
```rust
// match 分支
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}

match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    _ => EXPRESSION, // _ 匹配剩余的所有情况
}

// if let 分支
if let PATTERN = SOME_VALUE {
    ...
}

// while let 条件循环
// Vec是动态数组
let mut stack = Vec::new();

// 向数组尾部插入元素
stack.push(1);
stack.push(2);
stack.push(3);

// stack.pop从数组尾部弹出元素
// pop 方法取出动态数组的最后一个元素并返回 Some(value)
while let Some(top) = stack.pop() {
    println!("{}", top);
}

// for 循环
let v = vec!['a', 'b', 'c'];
// enumerate 方法产生一个迭代器
// 该迭代器每次迭代会返回一个 (索引，值) 形式的元组
// 然后用 (index,value) 来匹配
for (index, value) in v.iter().enumerate() {
    println!("{} is at index {}", value, index);
}

// let 语句
let PATTERN = EXPRESSION;
// x 也是一种模式绑定，代表将匹配的值绑定到变量 x 上
// 在 Rust 中,变量名也是一种模式
let x = 5;
// 将一个元组与模式进行匹配(模式和值的类型必需相同！)
// 对于元组来说，元素个数也是类型的一部分！
let (x, y, z) = (1, 2, 3);

// 函数参数
fn foo(x: i32) { // x 就是一个模式
    // ...
}

fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
```
