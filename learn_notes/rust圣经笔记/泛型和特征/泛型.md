# 泛型 Generics
- 泛型就是一种多态。泛型主要目的是为程序员提供编程的便利，减少代码的臃肿，同时可以极大地丰富语言本身的表达能力
```rust
// 示例 编译不通过
fn add<T>(a:T, b:T) -> T {
    a + b
}

fn main() {
    println!("add i8: {}", add(2i8, 3i8));
    println!("add i32: {}", add(20, 30));
    println!("add f64: {}", add(1.23, 1.23));
}
```

- T 就是泛型参数, rust 的泛型参数名可以随意起, 但是出于惯例, 都用 T(Type) 作为首选
- 使用泛型参数前必须对其进行声明
```rust
// largest<T> 对泛型参数 T 进行了声明
// 然后才在函数参数中进行使用该泛型参数 list: &[T]
// &[T] 是数组切片
// 函数 largest 有泛型类型 T
// 它有个参数 list
// 其类型是元素为 T 的数组切片
// 最后，该函数返回值的类型也是 T
fn largest<T>(list: &[T]) -> T {
```
- T 可以是任何类型，但不是所有类型都能进行比较, 也不是所有类型都能进行相加操作, 因此对T做比较和相加操作时需要对T进行限制
    - 比较: <T: std::cmp::PartialOrd>
    - 相加: <T: std::ops::Add<Output = T>>
```rust
// 比较
fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}

// 相加
fn add<T: std::ops::Add<Output = T>>(a:T, b:T) -> T {
    a + b
}

fn main() {
    println!("add i8: {}", add(2i8, 3i8));
    println!("add i32: {}", add(20, 30));
    println!("add f64: {}", add(1.23, 1.23));
}
```

## 结构体中使用泛型
- 结构体的字段类型可以使用泛型定义, 定义前需要声明
- 相同泛型参数的两个字段在赋值时的类型也必须相同
```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```
- 如果想让结构体两个字段既能类型相同又能类型不同, 就需要使用不同的泛型参数
```rust
struct Point<T,U> {
    x: T,
    y: U,
}
fn main() {
    let p = Point{x: 1, y :1.1};
}
```

## 枚举中使用泛型
- 枚举类型--Option 关注值是否存在
    - 使用泛型前需要声明
- Option引入泛型后可以用在任何一个需要返回值的函数中, 返回一个任意类型的值 Some(T)，或者没有值 None
```rust
// Option<T> 是一个拥有泛型 T 的枚举类型
enum Option<T> {
    // 第一个成员是 Some(T)
    // 存放了一个类型为 T 的值
    Some(T),
    None,
}
```
- 枚举类型--Result 关注值是否正确
    - 使用泛型前需要声明
- Result引入泛型后可以用在任何一个需要返回值的函数中, 如果函数正常运行，则最后返回一个 Ok(T)，T 是函数具体的返回值类型，如果函数异常运行，则返回一个 Err(E)，E 是错误类型
    - eg. 打开一个文件：如果成功打开文件，则返回 Ok(std::fs::File)，因此 T 对应的是 std::fs::File 类型；而当打开文件时出现问题时，返回 Err(std::io::Error)，E 对应的就是 std::io::Error 类型
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

## 方法中使用泛型
- 使用泛型前需要声明: impl<T>
```rust
struct Point<T> {
    x: T,
    y: T,
}

// 声明 impl<T> 后
// Rust 就知道 Point 的尖括号中的类型是泛型而不是具体类型
// 注意: Point<T> 不再是泛型声明
// 而是一个完整的结构体类型
// 因为我们定义的结构体就是 Point<T> 而不再是 Point
impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```
- 可以在结构体中定义泛型参数, 还可以在结构体的方法中定义额外的泛型参数, 类比泛型函数
```rust
struct Point<T, U> {
    x: T,
    y: U,
}

impl<T, U> Point<T, U> {
    // T,U 是定义在结构体 Point 上的泛型参数
    // V,W 是单独定义在方法 mixup 上的泛型参数
    // 它们并不冲突
    // 可以理解为
    // 一个是结构体泛型
    // 一个是函数泛型
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c'};

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```

### 为具体的泛型类型实现方法
- 针对特定的泛型类型实现某个特定的方法, 而其他泛型类型则没有定义该方法
```rust
// Point<f32> 类型会有一个方法 distance_from_origin
// 而其他 T 不是 f32 类型的 Point<T> 实例则没有定义此方法
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

## const 泛型（Rust 1.51 版本引入的重要特性）
- 针对类型实现的泛型，所有的泛型都是为了抽象不同的类型
- const 泛型则是为了抽象不同的常量, 针对值实现的泛型
```rust
// [i32; 3] 和 [i32; 2] 是两个不同的类型
// 数组长度也是类型的一部分
fn display_array(arr: [i32; 3]) {
    println!("{:?}", arr);
}
fn main() {
    let arr: [i32; 3] = [1, 2, 3];
    display_array(arr);

    let arr: [i32;2] = [1,2];
    display_array(arr);
}
// 运行后会报错 mismatched types 类型不匹配

// 修改如下:
// 使用数组切片，传入 arr 的不可变引用
// 使得 display_array 能打印任意长度的 i32 数组
fn display_array(arr: &[i32]) {
    println!("{:?}", arr);
}
fn main() {
    let arr: [i32; 3] = [1, 2, 3];
    display_array(&arr);

    let arr: [i32;2] = [1,2];
    display_array(&arr);
}

// 继续修改:
// 将 i32 改成所有类型的数组
// 注意:
// 对 T 加一个限制 std::fmt::Debug
// 该限制表明 T 可以用在 println!("{:?}", arr) 中
// 因为 {:?} 形式的格式化输出需要 arr 实现该特征
fn display_array<T: std::fmt::Debug>(arr: &[T]) {
    println!("{:?}", arr);
}
fn main() {
    let arr: [i32; 3] = [1, 2, 3];
    display_array(&arr);

    let arr: [i32;2] = [1,2];
    display_array(&arr);
}

// 继续修改:
// 定义了一个类型为 [T; N] 的数组
// T 是一个基于类型的泛型参数
// N 是一个基于值的泛型参数
// N 是用来替代的是数组的长度
// N 就是 const 泛型
// 定义的语法是 const N: usize
// 表示 const 泛型 N ，它基于的值类型是 usize

fn display_array<T: std::fmt::Debug, const N: usize>(arr: [T; N]) {
    println!("{:?}", arr);
}
fn main() {
    let arr: [i32; 3] = [1, 2, 3];
    display_array(arr);

    let arr: [i32; 2] = [1, 2];
    display_array(arr);
}
```

### const 泛型表达式
- 假设某段代码需要在内存很小的平台上工作，因此需要限制函数参数占用的内存大小，此时就可以使用 const 泛型表达式来实现
```rust
// 目前只能在nightly版本下使用
#![allow(incomplete_features)]
#![feature(generic_const_exprs)]

fn something<T>(val: T)
where
    Assert<{ core::mem::size_of::<T>() < 768 }>: IsTrue,
    //       ^-----------------------------^ 这里是一个 const 表达式，换成其它的 const 表达式也可以
{
    //...
}

fn main() {
    something([0u8; 0]); // ok
    something([0u8; 512]); // ok
    something([0u8; 1024]); // 编译错误，数组长度是1024字节，超过了768字节的参数长度限制
}
```

## 泛型的性能
- Rust 通过在编译时进行泛型代码的单态化(monomorphization)来保证使用泛型的效率
    - 单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程
```rust
let integer = Some(5);
let float = Some(5.0);

// 当 Rust 编译这些代码的时候
// 它会进行单态化
// 编译器会读取传递给 Option<T> 的值并发现有两种 Option<T>：
// 一种对应 i32 另一种对应 f64
// 为此，它会将泛型定义 Option<T> 展开为 Option_i32 和 Option_f64
// 接着将泛型定义替换为这两个具体的定义
// 单态化后
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```