# 特征 trait
- trait 跟接口很类似
- 特征定义了一组可以被共享的行为，只要实现了特征，你就能使用这组行为

## 定义特征
- 如果不同的类型具有相同的行为，那么我们就可以定义一个特征，然后为这些类型实现该特征
- 定义特征是把一些方法组合在一起，目的是定义一个实现某些目标所必需的行为的集合
```rust
// 使用 trait 关键字来声明一个特征
// Summary 是特征名
// 在大括号中定义了该特征的所有方法，
pub trait Summary {
    // 特征只定义行为看起来是什么样的，而不定义行为具体是怎么样的
    // 因此，我们只定义特征方法的签名，而不进行实现，此时方法签名结尾是 ;，而不是一个 {}
    // 感觉很像 Go 的 interface
    fn summarize(&self) -> String;
}
// 每一个实现这个特征的类型都需要具体实现该特征的相应方法
// 编译器也会确保任何实现 Summary 特征的类型
// 都拥有与这个签名的定义完全一致的 summarize 方法
```

## 为类型实现特征
```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
pub struct Post {
    pub title: String, // 标题
    pub author: String, // 作者
    pub content: String, // 内容
}

// impl Summary for Post
// 读作“为 Post 类型实现 Summary 特征”
// 然后在 impl 的花括号中实现该特征的具体方法
impl Summary for Post {
    fn summarize(&self) -> String {
        format!("文章{}, 作者是{}", self.title, self.author)
    }
}

pub struct Weibo {
    pub username: String,
    pub content: String
}

impl Summary for Weibo {
    fn summarize(&self) -> String {
        format!("{}发表了微博{}", self.username, self.content)
    }
}

fn main() {
    let post = Post{title: "Rust语言简介".to_string(),author: "Sunface".to_string(), content: "Rust棒极了!".to_string()};
    let weibo = Weibo{username: "sunface".to_string(),content: "好像微博没Tweet好用".to_string()};

    println!("{}",post.summarize());
    println!("{}",weibo.summarize());
}

// 运行结果
// 文章 Rust 语言简介, 作者是Sunface
// sunface发表了微博好像微博没Tweet好用
```

### 特征定义与实现的位置(孤儿规则)
- 关于特征实现与定义的位置，有一条非常重要的原则：如果你想要为类型 A 实现特征 T，那么 A 或者 T 至少有一个是在当前作用域中定义的, 该规则被称为孤儿规则，可以确保其它人编写的代码不会破坏你的代码，也确保了你不会莫名其妙就破坏了风马牛不相及的代码

### 默认实现
- 可以在特征中定义具有默认实现的方法，这样其它类型无需再实现该方法，或者也可以选择重载该方法：
```rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}

impl Summary for Post {}

impl Summary for Weibo {
    fn summarize(&self) -> String {
        format!("{}发表了微博{}", self.username, self.content)
    }
}

fn main() {
    println!("{}",post.summarize());
    println!("{}",weibo.summarize());
}

// 运行结果
// (Read more...)
// sunface发表了微博好像微博没Tweet好用
```
- 默认实现允许调用相同特征中的其他方法，哪怕这些方法没有默认实现
```rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}

impl Summary for Weibo {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}

fn main() {
    println!("1 new weibo: {}", weibo.summarize());
}
```

## 使用特征作为函数参数
```rust
// impl Summary: 实现了Summary特征 的 item 参数
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
// 可以使用任何实现了 Summary 特征的类型作为该函数的参数
// 同时在函数体内，还可以调用该特征的方法
// 例如 summarize 方法。具体的说，可以传递 Post 或 Weibo 的实例来作为参数
```

## 特征约束(trait bound)
- impl Trait 只是一个语法糖
- T: Summary 被称为特征约束
```rust
pub fn notify(item: &impl Summary) {  // 语法糖
    println!("Breaking news! {}", item.summarize());
}

pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

```rust
// 函数传参只要实现了 Summary 特征即可, 两个传参可以是不同类型
pub fn notify(item1: &impl Summary, item2: &impl Summary) {}

// 函数传参除了实现了 Summary 特征, 两个传参还必须是相同类型
// 泛型类型 T 说明了 item1 和 item2 必须拥有同样的类型
// 同时 T: Summary 说明了 T 必须实现 Summary 特征
pub fn notify<T: Summary>(item1: &T, item2: &T) {}
```

### 多重约束
- 通过 + 符号可以指定多个特征约束
```rust
pub fn notify(item: &(impl Summary + Display)) {}

pub fn notify<T: Summary + Display>(item: &T) {}
```


### where 约束
- 有点像sql的where条件, 神他喵想出这样写
```rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {}

fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{}
```

### 使用特征约束有条件地实现方法或特征
- 特征约束，可以让我们在指定类型 + 指定特征的条件下去实现方法
```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self {
            x,
            y,
        }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```
- 有条件的实现特征
eg. 标准库为任何实现了 Display 特征的类型实现了 ToString 特征
```rust
// 为任何实现了 Display 特征的类型实现 ToString 特征
impl<T: Display> ToString for T {
    // --snip--
}
```

## 函数返回中的 impl Trait
- 可以通过 impl Trait 来说明一个函数返回了一个类型，该类型实现了某个特征
- 多用于返回的真实类型非常复杂时，不知道该怎么声明时(毕竟 Rust 要求你必须标出所有的类型)，此时就可以用 impl Trait 的方式简单返回
    - 注意：返回时只能有一个具体的类型，不能返回实现该特征的不同类型
```rust
fn returns_summarizable() -> impl Summary {
    // 因为 Weibo 实现了 Summary
    // 因此这里可以用它来作为返回值
    Weibo {
        username: String::from("sunface"),
        content: String::from(
            "m1 max太厉害了，电脑再也不会卡",
        )
    }
}
// 但是对于 returns_summarizable 的调用者而言
// 他只知道返回了一个实现了 Summary 特征的对象
// 并不知道返回了一个 Weibo 类型
```

## 修复上一节中的 largest 函数
```rust
// std::cmp::PartialOrd
// PartialOrd 位于 prelude 中
// 所以并不需要通过 std::cmp 手动将其引入作用域, 可以直接用
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {}
```

## 通过 derive 派生特征
- 特征派生语法 `#[derive(Debug)]`, 被 derive 标记的对象会自动实现对应的默认特征代码，继承相应的功能
- derive 派生出来的是 Rust 默认给我们提供的特征，在开发过程中极大的简化了自己手动实现相应特征的需求，也可以自己手动重载该实现

## 调用方法需要引入特征
```rust
// 引入 std::convert::TryInto 特征
// 如果要使用一个特征的方法
// 那么需要将该特征引入当前的作用域中
use std::convert::TryInto;

fn main() {
  let a: i32 = 10;
  let b: u16 = 100;

  let b_ = b.try_into().unwrap();

  if a < b_ {
    println!("Ten is less than one hundred.");
  }
}

//  Rust 又提供了一个非常便利的办法
// 即把最常用的标准库中的特征通过 std::prelude 模块提前引入到当前作用域中
// 其中包括了 std::convert::TryInto
// 可以删掉第一行试试
```

## 综合例子
### 为自定义类型实现 + 操作
在 Rust 中除了数值类型的加法，String 也可以做加法，因为 Rust 为该类型实现了 std::ops::Add 特征，同理，如果我们为自定义类型实现了该特征，那就可以自己实现 Point1 + Point2 的操作:
```rust
use std::ops::Add;

// 为Point结构体派生Debug特征，用于格式化输出
#[derive(Debug)]
struct Point<T: Add<T, Output = T>> { //限制类型T必须实现了Add特征，否则无法进行+操作。
    x: T,
    y: T,
}

// T: Add<T, Output = T> 特征约束，限制T必须实现了Add特征，否则无法进行+操作。
impl<T: Add<T, Output = T>> Add for Point<T> {
    type Output = Point<T>;

    fn add(self, p: Point<T>) -> Point<T> {
        Point{
            x: self.x + p.x,
            y: self.y + p.y,
        }
    }
}

fn add<T: Add<T, Output=T>>(a:T, b:T) -> T {
    a + b
}

fn main() {
    let p1 = Point{x: 1.1f32, y: 1.1f32};
    let p2 = Point{x: 2.1f32, y: 2.1f32};
    println!("{:?}", add(p1, p2));

    let p3 = Point{x: 1i32, y: 1i32};
    let p4 = Point{x: 2i32, y: 2i32};
    println!("{:?}", add(p3, p4));
}
```

### 自定义类型的打印输出
- 在开发过程中，使用 #[derive(Debug)] 对我们的自定义类型进行标注，即可实现打印输出的功能、
```rust
#[derive(Debug)]
struct Point{
    x: i32,
    y: i32
}
fn main() {
    let p = Point{x:3,y:3};
    println!("{:?}",p);
}
```

- 在实际项目中，为了让用户更好的阅读理解我们的类型，就需要对我们的自定义类型进行自定义的格式化输出，此时就要为自定义类型实现 std::fmt::Display 特征
```rust
#![allow(dead_code)]

use std::fmt;
use std::fmt::{Display};

#[derive(Debug,PartialEq)]
enum FileState {
  Open,
  Closed,
}

#[derive(Debug)]
struct File {
  name: String,
  data: Vec<u8>,
  state: FileState,
}

impl Display for FileState {
   fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
     match *self {
         FileState::Open => write!(f, "OPEN"),
         FileState::Closed => write!(f, "CLOSED"),
     }
   }
}

impl Display for File {
   fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
      write!(f, "<{} ({})>",
             self.name, self.state)
   }
}

impl File {
  fn new(name: &str) -> File {
    File {
        name: String::from(name),
        data: Vec::new(),
        state: FileState::Closed,
    }
  }
}

fn main() {
  let f6 = File::new("f6.txt");
  //...
  println!("{:?}", f6);
  println!("{}", f6);
}
```